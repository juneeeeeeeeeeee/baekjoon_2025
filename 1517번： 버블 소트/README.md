# 1517번: 버블 소트 - `<img src="https://static.solved.ac/tier_small/16.svg" style="height:20px" />` Platinum V

<!-- performance -->

<!-- 문제 제출 후 깃허브에 푸시를 했을 때 제출한 코드의 성능이 입력될 공간입니다.-->

<!-- end -->

## 문제

[문제 링크](https://boj.kr/1517)

<p>N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.</p>

<p>버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.</p>

## 입력

<p>첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 들어있다.</p>

## 출력

<p>첫째 줄에 Swap 횟수를 출력한다</p>

## 해결방법

<p>생각할 거리가 굉장히 많았다. 이런저런 사이트들을 많이 참고했다. </p>

<p>1) 각 숫자에 대해, swap하는 횟수를 세려면 자기보다 작은 숫자가 오른쪽에 몇 개 있는지 세야 한다. (큰 것과 작은 것의 swap에 대해 큰 것만 1회로 센다. )</p>

<p>2) 이때, "나 여기 있어요" segment tree를 만든다. 가장 작은 배열의 idx부터, 자신의 오른쪽의 segment tree sum을 더하고, segment tree에 자신이 해당 idx에 있음을 update한다. 해당하는 segment tree는 sum과 update만을 필요로 하며, update는 해당 idx를 포함하는 구간을 +1씩 하므로 diff와 같은 변수를 필요로 하지 않는다. </p>

<p>3) 그렇다면 가장 작은 배열의 idx는 minheap과 같은 방법으로 찾을 수 있다. 이때 같은 배열의 값들이 문제가 된다. 왜냐하면 순서가 꼬여버려서 segment tree에서 sum을 더할 때 같은 값임에도 더해지는 일이 벌어질 수 있기 때문이다. (당연하지만 같은 값들끼리는 서로 swap할 필요가 없다. )</p>

<p>4) 따라서 segment tree에서 sum을 더하는 과정이 왼쪽 idx부터 일어나게 하려면, minheap을 정렬하는 기준에 idx도 넣어야 한다. </p>

<p>5) 마지막 함?정으로 배열들(array, minheap, segtree)은 int 범위이지만, 답은 long long int 범위이다. 버블 소트의 시간 복잡도가 N^2에 비례하니 당연한 부분. </p>

<p>여러모로 어려운 문제였다. </p>
